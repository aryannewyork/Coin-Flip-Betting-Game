// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.8.0;


contract C {

  // Creating a strcture to store the data associated with each individual address (user)
  // bet - The bet that user will make, the values will be either 0 (zero) or 1 (one). 0 for heads and 1 for tales.
  // amount - This will contain the amount that user has put on as bet. This will also contain the balance amount that user will obtain after the bets are evaluated.
  // isPlaying - This will make sure that the same user cannot place multiple bets, if they have an existing undecided bet.
  struct Bets {
    uint256 bet;
    uint256 amount;
    bool isPlaying;
  }
  
  // This is Harmony's inbuilt "Verifiable Random Function", that provides a cryptographically verifiable random number.
  // The result returned by the vrf() function will be used to generate the random coin toss guess, either 0 or 1.
  function vrf() internal view returns (bytes32 result) {
    uint[1] memory bn;
    bn[0] = block.number;
    assembly {
      let memPtr := mload(0x40)
      if iszero(staticcall(not(0), 0xff, bn, 0x20, memPtr, 0x20)) {
        invalid()
      }
      result := mload(memPtr)
    }
  }

  // The randomNumGen() function uses the result generated by the vrf() function to produce a random guess, either 0 or 1 (head or tail).
  // First the number is typecasted from byte32 (hexadecimal) to uint256(decimal). Mod 2 is used to obtain only 0 or 1 as guesses. To contract the randge of guesses.
    function randonNumGen() internal view returns (uint256) {
        return uint256(vrf())%2;
    }

  // The mapping called userBets will contain each instance of a user who makes the bet.
  // An array userAdd is used so that after all the bets have been made, we can iterate over them to evaluate the bets one by one. Since we can't iterate over a map.
    mapping (address => Bets) userBets;
    address[] userAdd;
  // An event is instantiated, that will be used to display the userAddress and their final balance after evaluation has been completed.
    event toBeEmitted(address userAddress, uint256 finalBal);

  //The makeBet() function takes in the bet of the user and bet amount.
    function makeBet(uint256 bet, uint256 betAmount) public {

      // The if statement makes sure that the user doesn't make multiple bets, until all the bets are evaluated.

      if(!userBets[msg.sender].isPlaying){
        userBets[msg.sender] = Bets(bet, betAmount, true);
        // The user cannot bet over 100 or under 0.
        require(userBets[msg.sender].amount <= 100, "DO NOT BET OVER 100");
        require(userBets[msg.sender].amount > 0, "DO NOT BET UNDER 0");
        userAdd.push(msg.sender);
      }
      else revert("CANNOT MAKE 2 BETS AT A TIME");
    }

  // This function simply evaluates the length of the userAdd array, we need this length to iterate over all the addresses, to evaluate them.
    function getUserCount() internal view returns (uint){
      return userAdd.length;
    }

  // After all the bets are made, rewardBets() function evaluates all the bets and updates the balance amount in the mapping that stores each users' game data.
    function rewardBets() public{
      for(uint i = 0; i < getUserCount(); i++){
        uint256 currRandom = randonNumGen();
        if(userBets[userAdd[i]].bet == currRandom){
          userBets[userAdd[i]].amount = 100 + userBets[userAdd[i]].amount;
        }
        else{
          userBets[userAdd[i]].amount = 100 - userBets[userAdd[i]].amount;
        }
        emit toBeEmitted(userAdd[i], userBets[userAdd[i]].amount);

        // This flag makes sure that, the user can make further bets if they don't have an unevaluated bet pending.
        userBets[userAdd[i]].isPlaying = false;
        // At this point the evaluation for i'th user is completed
      }
      // After all the bets are evaluated the array containing user addresses is cleared, to prevent reevaluation of bets by the same user, in next rounds.
      delete userAdd;
    }

}

